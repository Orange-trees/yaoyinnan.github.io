<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Cost aware cache replacement policy in shared last-level cache for hybrid memory based fog computing | Yaoyinnan's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Cost aware cache replacement policy in shared last-level cache for hybrid memory based fog computing</h1><a id="logo" href="/.">Yaoyinnan's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Cost aware cache replacement policy in shared last-level cache for hybrid memory based fog computing</h1><div class="post-meta">Oct 7, 2018</div><div class="post-content"><blockquote>
<p>基于雾计算的混合内存下的共享LLC缓存成本感知缓存替换策略</p>
</blockquote>
<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>由于高功耗，动态随机存取存储器（DRAM）通常使用随机存取存储器，不能被包含在雾计算系统中。</p>
<p>非易失性记忆（NVM），如相变内存（PCM）和自旋转移扭矩RAM（STT-RAM），其低功耗，取代了DRAM。混合主存储器，包括DRAM和NVM，在可伸缩性和功耗方面都显示出了很好的优势。</p>
<p>NVM的缺点：例如长读/写延迟，会导致潜在的问题，导致混合主存储器中的非对称缓存丢失。</p>
<p>当前的最后一级缓存（LLC）策略是基于统一未命中的成本，并导致LLC的表现不佳，并增加了使用NVM的成本。</p>
<p><strong>为了最小化混合主存储器中的缓存遗漏成本，我们提出了一个成本敏感的缓存替换策略（CACRP），它减少了NVM的缓存丢失的数量，并提高了混合内存系统的缓存性能。</strong></p>
<h4 id="Ⅰ-Introduction-前言"><a href="#Ⅰ-Introduction-前言" class="headerlink" title="Ⅰ.Introduction 前言"></a>Ⅰ.Introduction 前言</h4><p>​    雾计算建议扩展云计算的覆盖范围，以在移动终端提供服务。其愿景是通过减少延迟和提高服务质量（QoS）来提高服务质量，因为这种雾计算需要很大的主存容量来处理计算资源的增加需求。动态随机存取存储器（DRAM），通常使用的随机存取存储器受到其高功耗（Li等人2012）和有限的可伸缩性（薛等人2011）的限制，使其不适合在移动终端的主存系统中使用。为了解决这些限制，近年来已经看到了非易失性记忆（NVM）的发展，如相变内存（PCM）（Nirschl等人2007），自旋转移转矩RAM（STT-RAM）（Dieny 2011）和电阻RAM（ReRAM）（Kawahara等人2012），具有更好的可伸缩性和更低的功耗。然而，这些新记忆的缺点是，在设计雾计算设备时，需要考虑更长的读/写延迟。一个很有前途的主要内存架构可以解决功耗和可伸缩性问题，同时保持读写的延迟，这是一种混合的DRAM/NVM内存的开发。因此，混合DRAM/NVM内存将应用于雾计算，因为它的能耗低，可伸缩性高。但是在当前的内存管理方法下，在NVM中，移动设备的性能将会降低。因此，不能保证QoS是无法接受的，这对于雾计算来说是不可接受的。在雾计算中提高移动设备的混合内存性能是当务之急，以提供高质量的服务。</p>
<p>​    图1中演示了包含DRAM和NVM介质的最流行的混合内存架构之一。这两种记忆媒介使用统一的物理地址空间。因此，为了利用这两种媒介的优点，<strong>经常读取</strong>的数据被分配给<strong>NVM内存</strong>，而<strong>频繁写入</strong>的数据被分配给<strong>DRAM内存</strong>。然而，这种混合内存架构的最好使用要求共享的最后一级缓存（LLC）策略解决NVM内存的长读/写延迟（Jia et al.2016a）。不幸的是，大多数现行的LLC策略（Jaleel等人，2010年;2014年Samira Khan和Alameldeen;Seshadri等人，2012年;和Xie 和Loh 2009）在不区分不同的记忆媒介的情况下，不能降低平均内存访问成本。LLC策略需要将DRAM访问与NVM访问区分开来，以便最小化NVM访问以提高LLC的性能。</p>
<p>​    我们的论文的贡献如下：</p>
<pre><code>1. 我们解释混合内存中使用的当前水平缓存替换策略的低性能。NVM数据的更高的替换成本降低了缓存性能，而没有区分成本。
2. 我们提出一个成本敏感的缓存替换政策（CACRP）。在CACRP中，有两个单独的替换策略，一个用于DRAM数据，另一个用于NVM数据。NVM数据替换的策略只是一个LRU策略，而DRAM数据替换的策略是基于成本的动态策略。这两种策略的组合提高了性能。
3. 我们使用不同的工作负载来评估所提议的方法。实验结果表明，CACRP对LLC的效果更好，与LRU相比，它能提高LLC的功效，达到43.6%（平均15.5%）。
</code></pre><h4 id="Ⅱ-Motivations-动机"><a href="#Ⅱ-Motivations-动机" class="headerlink" title="Ⅱ.Motivations 动机"></a>Ⅱ.Motivations 动机</h4><p>​    图2展示了使用LRU替代策略在混合内存不同配置下的标准化完成时间。x轴代表不同的配置（1:15表示DRAM和NVM之间的内存容量比为1到15）。y轴表示完成时间规范化为仅用于DRAM的内存。随着NVM的比例降低，缓存性能会显著增加，但是整个缓存容量和主要内存容量都是固定的。图3展示了NVM数据增加的NVM数据的比例，导致其缓存的比例增加。在NVM中，一个未被缓存的缓存的成本较高，因为延迟的延迟会导致进程的完成时间的增加和性能的降低。公式（1）表示在一个仅为DRAM的主存中，平均内存访问时间:<br>$$<br>AT_{memory} = H <em> T_{cache} + M </em> T_memory<br>$$<br>​    $$AT_{memory}$$表示平均内存访问时间，H是缓存命中率，$$T_{cache}$$是缓存访问时间，$$M$$是缓存遗漏比率，而$$T_{memory}$$是内存访问时间。$$AT_{memory}$$越小，缓存性能就越好。在公式（1）中，$$T_{cache}$$和$$T_{memory}$$是恒定的，而$$H$$是$$1 - M$$，因此，在一个只有DRAM的主存中，增加缓存命中率将导致$$AT_{memory}$$的减少，以及缓存性能的提高。因此，传统LLC缓存替换策略的唯一目的是提高缓存命中率。但是在混合内存系统中，平均内存访问时间可以用公式（2）表示：<br>$$<br>AT_{hmemory} = H <em> T_{cache} + M_D </em> T_memory_D + M_N * T_memory_N<br>$$<br>​    $$AT_hmemory$$代表平均混合内存访问时间,$$H$$代表缓存命中率,$$T_{cache}$$代表缓存访问时间,医学博士代表了缓存错过DRAM的比例数据,$$T_{memory_D}$$代表DRAM内存访问时间,MN表示缓存错过NVM的比例数据,和$$T_{memory_N}$$代表NVM内存访问时间。</p>
<p>​    $$AT_{hmemory}$$越小，混合内存系统的缓存性能就越好。在公式（2）中，$$T_{cache}$$、$$T_{memory_D}$$和$$T_{memory_N}$$都是常量，$$H=1-MD-MN$$。此外，$$T_{memory_N}  &gt; T_{memory_D}$$。因此，为了提高混合内存系统的缓存性能，我们不仅需要增加缓存命中率，而且还需要减少NVM数据的缓存遗漏率。</p>
<p>​    在缓存替换策略方面，仅DRAM内存和一个混合的主存储器之间的主要区别在于它们处理缓存遗漏比的方法。在本文中，我们提出了一个成本感知缓存替换策略（CACRP），它旨在通过减少NVM数据的缓存遗漏率来提高缓存性能。</p>
<h4 id="Ⅲ-Cost-aware-cache-replacement-policy-CACRP-成本感知的缓存替换策略"><a href="#Ⅲ-Cost-aware-cache-replacement-policy-CACRP-成本感知的缓存替换策略" class="headerlink" title="Ⅲ.Cost aware cache replacement policy (CACRP) 成本感知的缓存替换策略"></a>Ⅲ.Cost aware cache replacement policy (CACRP) 成本感知的缓存替换策略</h4><h5 id="3-1-Overview-of-CACRP-概述"><a href="#3-1-Overview-of-CACRP-概述" class="headerlink" title="3.1 Overview of CACRP 概述"></a>3.1 Overview of CACRP 概述</h5><p>​    图4显示了支持CACRP的框架的概述。我们的CACRP主要由三个步骤组成：</p>
<ol>
<li>区分DRAM数据和NVM数据之间的缓存栈。</li>
<li>计算DRAM和NVM的成本损失，影响成本的过程行为。</li>
<li>根据DRAM和NVM的不同成本，确定DRAM数据的插入位置。我们的CACRP的目的是为了提高缓存的性能，减少NVM数据的误差率。因此，我们需要尽可能长时间地将NVM数据的缓存栈保存在缓存中。</li>
</ol>
<p>​    在这篇文章中，我们的CACRP将NVM数据插入到最近使用的（MRU）的位置，在一个命中或一个新负载之后，但是DRAM数据根据一个命中或一个新的负载在一个特定的位置插入。通过这种方式，我们的方法能够在缓存中延长NVM数据，以减少遗漏的比率。</p>
<h5 id="3-2-Cache-line-distinguishing-mechanism-缓存栈区分机制"><a href="#3-2-Cache-line-distinguishing-mechanism-缓存栈区分机制" class="headerlink" title="3.2. Cache line distinguishing mechanism 缓存栈区分机制"></a>3.2. Cache line distinguishing mechanism 缓存栈区分机制</h5><p>​    为了实现我们的CACRP，优先级的工作是区分DRAM数据和NVM数据的缓存栈。为了在不同的数据缓存栈路上实现不同的缓存替换策略，这是必需的。NVM数据缓存栈,我们将数据插入到最近使用后(系统)的位置或一个新的负载,而在DRAM数据高速缓存栈路的情况下,我们插入在基于成本命中后的特定位置或一个新的负载。</p>
<p>​    在本文中，我们采用了一种简单的方法来区分DRAM数据和NVM数据的缓存栈。算法1显示了区别机制。在这个算法中，我们做了两个假设：</p>
<ol>
<li><p>DRAM和NVM的主要内存是连续的;</p>
</li>
<li><p>DRAM的主要内存位于地址空间的小区域，而NVM的主要内存位于地址空间的大区域。</p>
</li>
</ol>
<p>​    这两个假设在当前的混合内存系统中是合理的。集合中的每一个缓存栈都包含一个惟一的标记，以区别于其他的。我们使用这个独特的标签来确定缓存栈是否来自于DRAM数据或NVM数据。</p>
<p>​    在算法中，$$T$$表示候选缓存栈的标记（正在进行判断），$$CL$$表示缓存栈的大小（主要是64字节或128字节）。$$S$$是最后一级缓存中缓存集的总数。$$N$$是混合主存储器中的DRAM大小。$$CA$$表示混合主存储器中候选缓存栈的物理地址。如果$$CA \% N == 0$$，这意味着候选缓存栈的物理地址小于$$N$$，因此它属于DRAM空间;否则，它属于NVM空间。例如，如果最后一级缓存是8 MB，而$$CL=64、S=8 K、N=512 MB$$，那么$$T=03C0 H$$.因此，$$CA=03C0 H 64 8 K=1e000000 H$$，因此，$$CA\%512 MB=0$$。因此，候选缓存栈路来自DRAM内存，因此，数据来自DRAM。</p>
<p>​    基于标签和我们的区分算法，很容易确定缓存栈是来自DRAM数据还是NVM数据。</p>
<h5 id="3-3-Replacement-cost-calculation-重置成本计算"><a href="#3-3-Replacement-cost-calculation-重置成本计算" class="headerlink" title="3.3. Replacement cost calculation 重置成本计算"></a>3.3. Replacement cost calculation 重置成本计算</h5><p>​    CACRP根据DRAM数据和NVM数据之间的缓存成本差异来确定DRAM数据的替换策略。公式（3）显示了DRAM数据的丢失成本：<br>$$<br>C_{DRAM} = R_{rDRAM} <em> T_{rDRAM} + R_{wDRAM} </em> T_{wDRAM}<br>$$<br>​    $$C_{DRAM}$$表示DRAM数据的丢失成本，$$R_{rDRAM}$$代表DRAM的读取率，$$T_{rDRAM}$$代表DRAM读取的存取周期，$$R_{wDRAM}$$代表DRAM的写比率，$$T_{wDRAM}$$代表DRAM写入的存取周期。在这个公式中，$$R_{rDRAM}+R_{wDRAM}=1$$和$$T_{rDRAM}=T_{wDRAM}$$。公式（4）显示NVM数据的成本：<br>$$<br>C_{NVM} = R_{rNVM} <em> T_{rNVM} + R_{wNVM} </em> T_{wNVM}<br>$$<br>​    $$C_{NVM}$$代表NVM数据的丢失成本，$$R_{rNVM}$$代表NVM的读取率，$$T_{rNVM}$$代表NVM读取的存取周期，$$R_{wNVM}$$表示NVM书写的写比，$$T_{wNVM}$$表示NVM书写的访问周期。在这个公式中，$$R_{rNVM}+R_{wNVM=1}$$和$$T_{wNVM}$$。因为记忆媒介的不同，$$T_{rNVM}$$，$$T_{rDRAM}$$，$$T_{wNVM}$$，$$T_{wDRAM}$$。因此，$$C_{DRAM}$$。但是为了确定替换位置，我们必须计算K的值，它满足$$C_{NVM}=K <em> C_{DRAM}$$的值。值K是确定插入位置所需的关键因素。公式（5）演示了计算K的过程：<br>$$<br>K = C_{NVM}/C_{DRAM}\= (R_{rNVM} </em> T_{rNVM} + R_{wNVM} <em> T_{wNVM})/(R_{rDRAM} </em> T_{rDRAM} + R_{wDRAM} <em> T_{wDRAM})\= (R_{rNVM} </em> T_{rNVM} + R_{wNVM} <em> T_{wNVM})/T_{rDRAM}<br>$$<br>​    在公式（5）中，$$T_{rNVM}$$、$$T_{wNVM}$$和$$T_{rDRAM}$$都是常量。但是$$R_{rNVM}$$和$$R_{wNVM}$$是变量。$$R_{rNVM}$$和$$R_{wNVM}$$的值决定了K的插入位置。$$R_{rNVM}$$和$$R_{wNVM}$$的值与正在运行的进程的行为有关，特别是DRAM的读和写行为。如果一个进程的行为包含50%的读和50%的内存，那么K的值是由$$K=（T_{rNVM}+T_{wNVM}）/（2 </em> T_{rDRAM}）$$给出的。</p>
<h5 id="3-4-Adaptive-position-replacement-policy-适应位置替换政策"><a href="#3-4-Adaptive-position-replacement-policy-适应位置替换政策" class="headerlink" title="3.4. Adaptive position replacement policy 适应位置替换政策"></a>3.4. Adaptive position replacement policy 适应位置替换政策</h5><p>​    每一个进程都有一个用于区分的K值，用于其不同的内存访问行为。为了提高缓存性能，我们必须将DRAM数据的缓存栈插入不同的位置。图5演示了这种自适应位置替换策略。在计算了K的值之后，我们可以确定在缓存栈路命中或新负载之后插入DRAM数据缓存栈的位置T。算法2显示了这种自适应位置替换策略。K是一个单一进程的公式（5）的结果。N表示最后一级缓存是N通道关联。P是插入位置，在这里插入DRAM缓存栈。如果K的值是1，这意味着DRAM和NVM的内存成本是相同的。因此，插入位置应该是MRU，也就是位置0。此外，通过我们的实验，我们确定当K的值接近4时，最佳的插入位置是13。插入位置随着K值的增加而增加。我们建立一个线性模型将插入位置与值K联系起来，因此，我们使用公式（6）来确定插入位置：</p>
<p>$$<br>P = -2K / 3 +  47/3<br>$$</p>
<p>​    在K大于1的情况下，插入位置将在0&lt;P&lt;15的范围内。通过这种方式，很容易确定插入位置。</p>
<p>​    通过算法2，我们可以确定一个命中或一个新负载后的DRAM缓存栈路的插入位置。但是对于NVM缓存线路，我们总是将它们插入到MRU位置。在这个替换策略中，NVM缓存线路可以在缓存中保存更长的时间，以降低成本。</p>
</div><div class="tags"><a href="/tags/缓存替换策略/">缓存替换策略</a></div><div class="post-nav"><a class="pre" href="/2018/10/11/CACHE_大数据存储DRAM／PCM混合存储器共享级缓存中的动态自适应替换策略/">Dynamic Adaptive Replacement Policy in Shared Last-Level Cache of DRAM/PCM Hybrid Memory for Big Data Storage</a><a class="next" href="/2018/10/05/ThinkPhp埋坑指南/">ThinkPhp埋坑指南</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/spider/" style="font-size: 15px;">spider</a> <a href="/tags/BT/" style="font-size: 15px;">BT</a> <a href="/tags/ThinkPHP/" style="font-size: 15px;">ThinkPHP</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/hbase/" style="font-size: 15px;">hbase</a> <a href="/tags/文献推荐/" style="font-size: 15px;">文献推荐</a> <a href="/tags/common/" style="font-size: 15px;">common</a> <a href="/tags/缓存替换策略/" style="font-size: 15px;">缓存替换策略</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/28/CACHE_提炼交换_一个高效的混合DRAM-NVM系统的交换机制/">Refinery swap_An efficient swap mechanism for hybrid DRAM–NVM systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/CACHE_使用自适应的多级独占缓存策略高效的缓存资源聚合/">Efficient cache resource aggregation using adaptive multi-level exclusive caching policies</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/CACHE_大数据存储DRAM／PCM混合存储器共享级缓存中的动态自适应替换策略/">Dynamic Adaptive Replacement Policy in Shared Last-Level Cache of DRAM/PCM Hybrid Memory for Big Data Storage</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/07/CACHE_基于雾计算的混合内存下的共享末级缓存成本感知缓存替换策略/">Cost aware cache replacement policy in shared last-level cache for hybrid memory based fog computing</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/05/ThinkPhp埋坑指南/">ThinkPhp埋坑指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/04/linux登录后出现-bash-4-1-，解决办法以及造成这样的原因/">linux登录后出现-bash-4.1$，解决办法以及造成这样的原因</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/CACHE_混合存储系统中基于遗漏感知的LRU缓存替换策略/">MALRU miss-penalty aware LRU-based cache replacement for hybrid memory systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/py-Hbase/">py-Hbase</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/BT/">BT</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/18/Git/">Git</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Yaoyinnan's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>